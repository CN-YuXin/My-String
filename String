#include "_TestVersion"

#if !defined(_STRING_OF_YX_) && _CPP_VERSION_ != 98
#define _STRING_OF_YX_

#include <ostream>
#include <istream>
#include <type_traits>
#include <string>
#include <initializer_list>
#include "ReverseIterator"
#include "Byte"

#ifdef USER_NAMESPACE
namespace USER_NAMESPACE {
#endif

template <typename T,typename SIZE_TYPE = size_t>
class BasicString final {
	static_assert(std::is_same<T,char>::value
		or std::is_same<T,wchar_t>::value
		or std::is_same<T,char32_t>::value
		or std::is_same<T,char16_t>::value,
		"Illegal type");
	static_assert(std::is_same<SIZE_TYPE,unsigned short>::value
		or std::is_same<SIZE_TYPE,unsigned int>::value
		or std::is_same<SIZE_TYPE,unsigned long>::value
		or std::is_same<SIZE_TYPE,unsigned long long>::value,
		"Illegal type");
 public:
	using sizeType             = SIZE_TYPE;
	using charType             = T;
	using iterator             = T*;
	using constIterator        = const T*;
	using reverseIterator      = ReverseIterator<iterator>;
	using constReverseIterator = const reverseIterator;
	const sizeType &length,
		&capacity;
	const constIterator &data;
	BasicString() noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(new T[15]),
		_size(0),
		_capacity(15) {
	}
	explicit BasicString(sizeType Cap) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(new T[Cap]),
		_size(0),
		_capacity(Cap) {
	}
	template <sizeType SIZE>
	BasicString(const T(&text)[SIZE]) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForText(text)),
		_size(SIZE - 1),
		_capacity(SIZE - 1) {
	}
	BasicString(BasicString&& move) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(move._data),
		_size(move._size),
		_capacity(move._capacity) {
		move._data = nullptr;
		
		move._size = 0;
		
		move._capacity = 0;
	}
	BasicString(const BasicString& copy) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForCopy(copy)),
		_size(copy._size),
		_capacity(copy._size) {
	}
	template <sizeType SIZE>
	BasicString(const volatile T(&arr)[SIZE], sizeType begin, sizeType end) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForArray(arr,begin,end)),
		_size(begin >= SIZE or end <= begin ? 0 : end - begin),
		_capacity(begin >= SIZE or end <= begin ? SIZE : _size) {
	}
	BasicString(const BasicString &txt, sizeType b, sizeType e) noexcept:
	 	length(_size),
	 	capacity(_capacity),
	 	data((decltype(data))_data),
	 	_data(initForString(txt,b,e)),
	 	_size(b >= txt.length or e <= b ? 0 : e - b),
	 	_capacity(b >= txt.length or e <= b ? txt.length : _size) {
	}
	BasicString(std::initializer_list<T> init) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForInit(init)),
		_size(init.size()),
		_capacity(init.size()) {
	}
	BasicString(const std::basic_string<T> &stxt) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForStdString(stxt)),
		_size(stxt.length()),
		_capacity(stxt.length()) {
	}
	BasicString(sizeType _co, T _c) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForChar(_c,_co)),
		_size(_co),
		_capacity(_co) {
	}
	BasicString(sizeType _co, const BasicString &_tx) noexcept:
		length(_size),
		capacity(_capacity),
		data((decltype(data))_data),
		_data(initForString(_tx,_co)),
		_size(_tx.length * _co),
		_capacity(_tx.length * _co) {
	}
	constexpr T* getData() const noexcept {
		return _data;
	}
	constexpr sizeType getLength() const noexcept {
		return _size;
	}
	constexpr sizeType getSize() const noexcept {
		return _size;
	}
	constexpr sizeType getCapacity() const noexcept {
		return _capacity;
	}
	constexpr T& getSecond() const noexcept {
		return _data[_size - 1];
	}
	constexpr T& getFirst() const noexcept {
		return _data[0];
	}
	//以下这些迭代器函数作用仅为兼容
	constexpr iterator begin() const noexcept {
		return _data;
	}
	constexpr iterator end() const noexcept {
		return _data + _size;
	}
	constexpr constIterator cbegin() const noexcept {
		return _data;
	}
	constexpr constIterator cend() const noexcept {
		return _data + _size;
	}
	constexpr reverseIterator rbegin() const noexcept {
	    return end() - 1;
	}
	constexpr reverseIterator rend() const noexcept {
	    return begin() - 1;
	}
	constexpr constReverseIterator crbegin() const noexcept {
	    return end() - 1;
	}
	constexpr constReverseIterator crend() const noexcept {
	    return begin() - 1;
	}
	constexpr T& operator[](sizeType index) const noexcept {
		return _data[index];
	}
	constexpr bool operator==(const BasicString &e) const noexcept {
		return equals(e);
	}
	template <sizeType S>
	constexpr bool operator==(const T(&rarr)[S]) const noexcept {
		return equals(rarr);
	}
	constexpr bool operator!=(const BasicString &e) const noexcept {
		return !equals(e);
	}
	template <sizeType S>
	constexpr bool operator!=(const T(&rarr)[S]) const noexcept {
		return !equals(rarr);
	}
	constexpr bool operator<(const BasicString &txt) const noexcept {
		return length < txt.length;
	}
	template <sizeType S>
	constexpr bool operator<(const T(&rarr)[S]) const noexcept {
		return length < S - 1;
	}
	constexpr bool operator<=(const BasicString &txt) const noexcept {
		return length <= txt.length;
	}
	template <sizeType S>
	constexpr bool operator<=(const T(&rarr)[S]) const noexcept {
		return length <= S - 1;
	}
	constexpr bool operator>(const BasicString &txt) const noexcept {
		return length > txt.length;
	}
	template <sizeType S>
	constexpr bool operator>(const T(&rarr)[S]) const noexcept {
		return length > S - 1;
	}
	constexpr bool operator>=(const BasicString &txt) const noexcept {
		return length >= txt.length;
	}
	template <sizeType S>
	constexpr bool operator>=(const T(&rarr)[S]) const noexcept {
		return length >= S - 1;
	}
	constexpr T& operator*() const noexcept {
		return _data[0];
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& appEnd(T c) noexcept {
		return insert(c,length);
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& appEnd(const BasicString &txt) noexcept {
		return insert(txt,length);
	}
	template <sizeType SIZE>
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& appEnd(const T(&rarr)[SIZE]) noexcept {
		return insert(rarr,length);
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& appFront(T c) noexcept {
		return insert(c,0);
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& appFront(const BasicString &txt) noexcept {
		return insert(txt,0);
	}
	template <sizeType SIZE>
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& appFront(const T(&rarr)[SIZE]) noexcept {
		return insert(rarr,0);
	}
	constexpr BasicString clone() const noexcept {
		return *this;
	}
	constexpr bool isNotEmpty() const noexcept {
		return !isEmpty();
	}
	BasicString& insert(T _c, sizeType _in) noexcept {
		if (_in > length)
			return *this;
		if (length == capacity) {
			reNew(_in,_in + 1);
		} else
			for (sizeType i = length;i > _in;--i)
				_data[i] = _data[i - 1];
		_data[_in] = _c;
		++_size;
		return *this;
	}
	BasicString& insert(const BasicString &txt, sizeType _in) noexcept {
		if (_in > length or txt.length == 0)
			return *this;
		if (length + txt.length > capacity) {
			reNew(_in, _in + txt.length, length + txt.length);
		} else
			for (sizeType i = length + (txt.length - 1);i > _in + (txt.length - 1);--i)
				_data[i] = _data[i - txt.length];
		for (sizeType i = _in;i < _in + txt.length;++i)
			_data[i] = txt[i - _in];
		_size += txt.length;
		return *this;
	}
	template <sizeType SIZE>
	BasicString& insert(const T(&rarr)[SIZE], sizeType _in) noexcept {
		if (_in > length or SIZE - 1 == 0)
			return *this;
		if (length + SIZE - 1 > capacity) {
			reNew(_in, _in + SIZE - 1, length + SIZE - 1);
		} else
			for (sizeType i = length + (SIZE - 2);i > _in + (SIZE - 2);--i)
				_data[i] = _data[i - (SIZE - 1)];
		for (sizeType i = _in;i < _in + SIZE - 1;++i)
			_data[i] = rarr[i - _in];
		_size += SIZE - 1;
		return *this;
	}
	bool isEmpty() const noexcept {
		if (length == 0)
			return true;
		for (sizeType i = 0;i < length;++i)
			if (_data[i] != 0)
				return false;
		return true;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	void clear() noexcept {
		return void(_size = 0);
	}
	BasicString& reverse(sizeType begin, sizeType end) noexcept {
		if (end <= begin or begin >= length)
			return *this;
		--end;
		for (;end > begin;++begin,--end) {
			T tmp        = _data[begin];
			_data[begin] = _data[end];
			_data[end]   = tmp;
		}
		return *this;
	}
	BasicString& reverse() noexcept {
		return reverse(0,_size);
	}
	bool reLowestCapacity(sizeType cap) noexcept {
		if (cap < _capacity) {
			return true;
		} else {
			reNew(0,0,cap);
			return false;
		};
	}
	sizeType find(T _char, sizeType _b, sizeType _e) const noexcept {
		if (_e <= _b or _b >= length or _e > length)
			return -1;
		for (sizeType i = _b;i < _e;++i)
			if (_data[i] == _char)
				return i;
		return -1;
	}
	constexpr sizeType find(T _c) const noexcept {
		return find(_c,0,length);
	}
	sizeType find(const BasicString &text, sizeType _b, sizeType _e) const noexcept {
		if (text.length == 0)
			return -1;
		for (sizeType i = _b;(i < _e and i < length) and i + text.length <= _e;++i)
			for (sizeType j = i;j < _e and j - i < text.length and _data[j] == text[j - i];++j)
				if (j - i == text.length - 1)
					return i;
		return -1;
	}
	template <sizeType SIZE>
	sizeType find(const T(&rarr)[SIZE], sizeType _b, sizeType _e) const noexcept {
		if (SIZE - 1 == 0)
			return -1;
		for (sizeType i = _b;(i < _e and i < length) and i + SIZE - 1 <= _e;++i)
			for (sizeType j = i;j < _e and j - i < SIZE - 1 and _data[j] == rarr[j - i];++j)
				if (j - i == SIZE - 2)
					return i;
		return -1;
	}
	constexpr sizeType find(const BasicString &t) const noexcept {
		return find(t,0,length);
	}
	template <sizeType SIZE>
	constexpr sizeType find(const T(&rarr)[SIZE]) const noexcept {
		return find(rarr,0,length);
	}
	template <typename F>
	sizeType findIf(F &&fn, sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (fn(data + i))
				return i;
		return -1;
	}
	template <typename F>
	constexpr sizeType findIf(F &&fn) const noexcept {
		return findIf(fn,0,length - 1);
	}
	sizeType rightFind(T _c, sizeType _b, sizeType _e) const noexcept {
		if (_e <= _b or _b >= length or _e > length)
			return -1;
		for (sizeType i = _e - 1;i < _e and i >= _b;--i)
			if (_data[i] == _c)
				return i;
		return -1;
	}
	constexpr sizeType rightFind(T _c) const noexcept {
		return rightFind(_c,0,length);
	}
	sizeType rightFind(const BasicString &text, sizeType _b, sizeType _e) const noexcept {
		if (text.length == 0)
			return -1;
		for (sizeType i = _e - text.length + 1;i >= _b and i < _e and i < length;--i) {
			for (sizeType j = i;j < _e and j - i < text.length and _data[j] == text[j - i];++j)
				if (j - i == text.length - 1)
					return i;
		 }
		return -1;
	}
	template <sizeType SIZE>
	sizeType rightFind(const T(&rarr)[SIZE], sizeType _b, sizeType _e) const noexcept {
		if (SIZE - 1 == 0)
			return -1;
		for (sizeType i = _e - (SIZE - 2);i >= _b and i < _e and i < length;--i) {
			for (sizeType j = i;j < _e and j - i < SIZE - 1 and _data[j] == rarr[j - i];++j)
				if (j - i == SIZE - 2)
					return i;
		}
		return -1;
	}
	constexpr sizeType rightFind(const BasicString &text) const noexcept {
		return rightFind(text,0,length);
	}
	template <sizeType SIZE>
	constexpr sizeType rightFind(const T(&rarr)[SIZE]) const noexcept {
		return rightFind(rarr,0,length);
	}
	template <typename F>
	sizeType rightFindIf(F &&fn, sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (fn(data + i))
				return i;
		return -1;
	}
	template <typename F>
	constexpr sizeType rightFindIf(F &&fn) const noexcept {
		return rightFindIf(fn,0,length);
	}
	sizeType count(T _c, sizeType _b, sizeType _e) const noexcept {
		if (_e <= _b)
			return 0;
		sizeType _count = 0;
		for (sizeType i = _b;i < _e and i < length;) {
			sizeType _res = find(_c,i,_e);
			if (_res != -1) {
				i = (++_count,_res + 1);
			} else
				break;
		}
		return _count;
	}
	constexpr sizeType count(T _c) const noexcept {
		return count(_c,0,length);
	}
	sizeType count(const BasicString &text, sizeType _b, sizeType _e) const noexcept {
		if (_e <= _b or _e < text.length)
			return 0;
		sizeType _count = 0;
		for (sizeType i = _b;i <= _e - text.length and i < length;) {
			sizeType _res = find(text,i,_e);
			if (_res != -1) {
				i = (++_count,_res + text.length);
			} else
				break;
		}
		return _count;	
	}
	template <sizeType SIZE>
	sizeType count(const T(&rarr)[SIZE], sizeType _b, sizeType _e) const noexcept {
		if (_e <= _b or _e < SIZE - 1)
			return 0;
		sizeType _count = 0;
		for (sizeType i = _b;i <= _e - (SIZE - 1) and i < length;) {
			sizeType _res = find(rarr,i,_e);
			if (_res != -1) {
				i = (++_count,_res + SIZE - 1);
			} else
				break;
		}
		return _count;	
	}
	constexpr sizeType count(const BasicString &txt) const noexcept {
		return count(txt,0,length);
	}
	template <sizeType SIZE>
	constexpr sizeType count(const T(&rarr)[SIZE]) const noexcept {
		return count(rarr,0,length);
	}
	sizeType erase(sizeType _in) noexcept {
		if (length == 0 or _in >= length)
			return -1;
		if (_in != length - 1)
			for (sizeType i = _in;i + 1 < length;++i)
				_data[i] = _data[i + 1];
		--_size;
		return 1;
	}
	sizeType erase(sizeType _b, sizeType _e) noexcept {
		if (_e <= _b or _b >= length or length == 0)
			return -1;
		sizeType _s = _e - _b;
		if (_e == length) {
			_size = _b;
			return _s;
		}
		for (sizeType i = _b;i + _s < length;++i)
			_data[i] = _data[i + _s];
		_size -= _s;
		return _s;
	}
	sizeType erase(sizeType b, sizeType e, T c) noexcept {
		if (e <= b or b >= length or length == 0)
			return -1;
		sizeType _count = 0;
		while (true) {
			sizeType _res = find(c,b,e);
			if (_res != -1) {
				erase(_res);
				--e,++_count;
			} else
				break;
		}
		return _count;
	}
	sizeType erase(sizeType b, sizeType e, const BasicString &txt) noexcept {
		if (e <= b or b >= length or length == 0)
			return -1;
		sizeType _count = 0;
		while (true) {
			sizeType _res = find(txt,b,e);
			if (_res != -1) {
				erase(_res,_res + txt.length);
				e -= txt.length,++_count;
			} else
				break;
		}
		return _count;
	}
	template <sizeType SIZE>
	sizeType erase(sizeType b, sizeType e, const T(&rarr)[SIZE]) noexcept {
		if (e <= b or b >= length or length == 0)
			return -1;
		sizeType _count = 0;
		while (true) {
			sizeType _res = find(rarr,b,e);
			if (_res != -1) {
				erase(_res,_res + SIZE - 1);
				e -= (SIZE - 1,++_count);
			} else
				break;
		}
		return _count;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	sizeType erase(const BasicString &txt) noexcept {
		return erase(0,length,txt);
	}
	template <sizeType SIZE>
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	sizeType erase(const T(&rarr)[SIZE]) noexcept {
		return erase(0,length,rarr);
	}
	sizeType fill(sizeType _b, sizeType _e , T _c) noexcept {
		if (_e <= _b or length == 0 or _b >= length)
			return -1;
		for (sizeType i = _b;i < _e and i < length;++i)
			_data[i] = _c;
		if (_e <= _b)
			return 0;
		return _e - _b;
	}
	BasicString& replace(T _rep, sizeType b, sizeType e, T _c) noexcept {
		if (b >= length or e <= b)
			return *this;
		for (sizeType i = b;i < e and i < length;++i)
			if (_data[i] == _c)
				_data[i] = _rep;
		return *this;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& replace(T r, T c) noexcept {
		return replace(r,0,length,c);
	}
	BasicString& replace(const BasicString &txt, sizeType b, sizeType e, T c) noexcept {
		if (txt.length == 0) {
			erase(c);
			return *this;
		} else if (b >= length or e <= b)
			return *this;
		while (true) {
			auto _res = find(c,b,e);
			if (_res != -1) {
				if (capacity < length + txt.length - 1) {
					reNew(_res, _res + txt.length - 1, length + txt.length - 1);
				} else
					for (sizeType i = e + txt.length - 2;i >= _res + txt.length;--i)
					_data[i] = _data[i - txt.length + 1];
				for (sizeType i = _res;i < _res + txt.length;++i)
					_data[i] = txt[i - _res];
				_size += txt.length - 1;
				b = _res + txt.length;
				e += txt.length - 1;
			} else
				break;
		}
		return *this;
	}
	template <sizeType SIZE>
	BasicString& replace(const T(&rarr)[SIZE], sizeType b, sizeType e, T c) noexcept {
		if (SIZE - 1 == 0) {
			erase(c);
			return *this;
		} else if (b >= length or e <= b)
			return *this;
		while (true) {
			auto _res = find(c,b,e);
			if (_res != -1) {
				if (capacity < length + SIZE - 2) {
					reNew(_res, _res + SIZE - 2, length + SIZE - 2);
				} else
					for (sizeType i = e + SIZE - 3;i >= _res + SIZE - 1;--i)
					_data[i] = _data[i - (SIZE - 1) + 1];
				for (sizeType i = _res;i < _res + SIZE - 1;++i)
					_data[i] = rarr[i - _res];
				_size += SIZE - 2;
				b = _res + SIZE - 1;
				e += SIZE - 2;
			} else
				break;
		}
		return *this;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& replace(const BasicString &txt, T _c) noexcept {
		return replace(txt,0,length,_c);
	}
	template <sizeType SIZE>
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& replace(const T(&rarr)[SIZE], T _c) noexcept {
		return replace(rarr,0,length,_c);
	}
	BasicString& replace(const BasicString &txt, sizeType b, sizeType e, const BasicString &str) noexcept {
		if (str.length == 0) {
			return *this;
		} else if (txt.length == 0) {
			erase(str);
			return *this;
		} else if (b >= length or e <= b) {
			return *this;
		}
		while (true) {
			sizeType _res = find(str,b,e);
			if (_res != -1) {
				if (txt.length == str.length) {
					for (sizeType i = _res;i < _res + txt.length;++i)
							_data[i] = txt[i - _res];
					for (sizeType i = _res;i < _res + txt.length;++i)
						_data[i] = txt[i - _res];
					b = _res + txt.length;
				} else if (txt.length > str.length) {
					if (capacity < length + txt.length - str.length) {
						reNew(_res,_res + txt.length - str.length,length + (txt.length - str.length));
					} else
						for (sizeType i = (e + txt.length - str.length) - 1;i >= _res + (txt.length - str.length) + 1;--i)
							_data[i] = _data[i - (txt.length - str.length)];
					for (sizeType i = _res;i < _res + txt.length;++i)
						_data[i] = txt[i - _res];
					_size += (txt.length - str.length);
					b = _res + txt.length;
					e += (txt.length - str.length);
				} else if (txt.length < str.length) {
					erase(_res + txt.length,_res + txt.length + (str.length - txt.length));
					for (sizeType i = _res;i < _res + txt.length;++i)
						_data[i] = txt[i - _res];
					b = _res + txt.length;
					e -= (str.length - txt.length);
				}
			} else
				break;
		}
		return *this;
	}
	template <sizeType SIZE, sizeType SIZE2>
	BasicString& replace(const T(&rarr)[SIZE], sizeType b, sizeType e, T(&str)[SIZE2]) noexcept {
		if (SIZE2 - 1 == 0) {
			return *this;
		} else if (SIZE - 1 == 0) {
			erase(str);
			return *this;
		} else if (b >= length or e <= b) {
			return *this;
		}
		while (true) {
			sizeType _res = find(str,b,e);
			if (_res != -1) {
				if (SIZE - 1 > SIZE2 - 1 and capacity < length + (SIZE - 1) - (SIZE2 - 1)) {
					reNew(0,length + ((SIZE - 1) - (SIZE2 - 1)));
				}
				if (SIZE - 1 == SIZE2 - 1) {
					for (sizeType i = _res;i < _res + SIZE - 1;++i)
						_data[i] = rarr[i - _res];
					for (sizeType i = _res;i < _res + SIZE - 1;++i)
						_data[i] = rarr[i - _res];
					b = _res + SIZE - 1;
				} else if (SIZE - 1 > SIZE2 - 1) {
					if (capacity < length + (SIZE - 1) - (SIZE2 - 1)) {
						reNew(_res,_res + (SIZE - 1) - (SIZE2 - 1),length + ((SIZE - 1) - (SIZE2 - 1)));
					} else
						for (sizeType i = (e + (SIZE - 1) - (SIZE2 - 1)) - 1;i >= _res + ((SIZE - 1) - (SIZE2 - 1)) + 1;--i)
							_data[i] = _data[i - ((SIZE - 1) - (SIZE2 - 1))];
					for (sizeType i = _res;i < _res + SIZE - 1;++i)
						_data[i] = rarr[i - _res];
					_size += ((SIZE - 1) - (SIZE2 - 1));
					b = _res + SIZE - 1;
					e += ((SIZE - 1) - (SIZE2 - 1));
				} else if (SIZE - 1 < SIZE2 - 1) {
					erase(_res + SIZE - 1,_res + SIZE - 1 + ((SIZE2 - 1) - (SIZE - 1)));
					for (sizeType i = _res;i < _res + SIZE - 1;++i)
						_data[i] = rarr[i - _res];
					b = _res + SIZE - 1;
					e -= ((SIZE2 - 1) - (SIZE - 1));
				}
			} else
				break;
		}
		return *this;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& replace(const BasicString &txt, const BasicString &str) noexcept {
		return replace(txt,0,length,str);
	}
	template <sizeType SIZE, sizeType SIZE2>
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& replace(const T(&rarr)[SIZE], T(&str)[SIZE2]) noexcept {
		return replace(rarr,0,length,str);
	}
	BasicString& toUpperCase(sizeType _b, sizeType _e) noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (_data[i] >= 97 and _data[i] <= 122)
				_data[i] -= 32;
		return *this;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& toUpperCase() noexcept {
		return toUpperCase(0,length);
	}
	BasicString& toLowerCase(sizeType _b, sizeType _e) noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (_data[i] >= 65 and _data[i] <= 90)
				_data[i] += 32;
		return *this;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& toLowerCase() noexcept {
		return toLowerCase(0,length);
	}
	#if _CPP_VERSION_ >= 14
		constexpr
	#endif
	BasicString& invertCase(sizeType _b, sizeType _e) noexcept {
		for (sizeType i = _b;i < _e and i < length;++i) {
			if (_data[i] >= 65 and _data[i] <= 90)
				_data[i] += 32;
			else if (_data[i] >= 97 and _data[i] <= 122)
				_data[i] -= 32;
		}
		return *this;
	}
	BasicString& invertCase() noexcept {
		return invertCase(0,length);
	}
	bool isInteger(sizeType _b, sizeType _e) const noexcept {
		bool _n = true;
		for (sizeType i = _b;i < _e and i < length;++i)
			if ((_data[i] == 45 or _data[i] == 43) and _n)
				continue;
			else if (_data[i] >= 48 and _data[i] <= 57)
				_n = false;
			else if (!(_data[i] >= 48 and _data[i] <= 57))
				return false;
		return true;
	}
	constexpr bool isInteger() const noexcept {
		return isInteger(0,length);
	}
	bool hasInteger(sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (_data[i] >= 48 and _data[i] <= 57)
				return true;
		return false;
	}
	constexpr bool hasInteger() const noexcept {
		return hasInteger(0,length);
	}
	bool isChar(sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (isInteger(i,i + 1))
				return false;
		return true;
	}
	constexpr bool isChar() const noexcept {
		return isChar(0,length);
	}
	bool hasChar(sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (!isInteger(i,i + 1))
				return true;
		return false;
	}
	constexpr bool hasChar() const noexcept {
		return hasChar(0,length);
	}
	bool isLetter(sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if (!((_data[i] >= 65 and _data[i] <= 90) or (_data[i] >= 97 and _data[i] <= 122)))
				return false;
		return true;
	}
	constexpr bool isLetter() const noexcept {
		return isLetter(0,length);
	}
	bool hasLetter(sizeType _b, sizeType _e) const noexcept {
		for (sizeType i = _b;i < _e and i < length;++i)
			if ((_data[i] >= 65 and _data[i] <= 90) or (_data[i] >= 97 and _data[i] <= 122))
				return true;
		return false;
	}
	constexpr bool hasLetter() const noexcept {
		return hasLetter(0,length);
	}
	std::string toStdString(sizeType _b, sizeType _e) const noexcept {
		std::string _r;
		for (sizeType i = _b;i < _e;++i)
			_r += _data[i];
		return _r;
	}
	std::string toStdString() const noexcept {
		return toStdString(0,length);
	}
	template <typename IT = int>
	IT toInteger(sizeType b, sizeType e) const noexcept {
		static_assert(std::is_integral<IT>::value
			and !std::is_same<IT,bool>::value,"Illegal type");
		if (!isInteger(b,e))
			return 0;
		bool _smal = false;
		IT _res = 0;
		for (sizeType i = b;i < e and i < length;++i) {
			if (_data[i] == 45) {
				_smal = !_smal;
				continue;
			} else if (_data[i] == 43) {
				continue;
			}
			_res += (-48 + _data[i]);
			if (i < e - 1)
				_res *= 10;
		}
		return _smal ? -_res : _res;
	}
	template <typename IT = int>
	constexpr IT toInteger() const noexcept {
		return toInteger(0,length);
	}
	#if _CPP_VERSION_ >= 17
	template <typename VALUE>
	bool equals(VALUE&& v) const noexcept {
		if constexpr (!std::is_same_v<std::remove_const_t<std::remove_reference_t<decltype(v)>>,BasicString>) {
			return false;
		} else {
			if (length != v.length)
				return false;
			for (sizeType i = 0;i < length;++i)
				if (_data[i] != v[i])
					return false;
		}
		return true;
	}
	#else
	bool equals(const BasicString& v) const noexcept {
		if (length != v.length)
			return false;
		else {
			for (sizeType i = 0;i < length;++i)
				if (_data[i] != v[i])
					return false;
		}
		return true;
	}
	#endif
	template <sizeType SIZE>
	bool equals(const volatile T(&rarr)[SIZE]) const noexcept {
		if (length != SIZE - 1)
			return false;
		for (sizeType i = 0;i < length;++i)
			if (_data[i] != rarr[i])
				return false;
		return true;
	}
	Byte<> compare(const BasicString& r) const noexcept {
		if (length > r.length) {
			return 1;
		} else if (length < r.length) {
			return -1;
		} else {
			for (sizeType i = 0;i < length;++i) {
				if (_data[i] > r[i]) {
					return 1;
				} else if (_data[i] < r[i]) {
					return -1;
				}
			}
		}
		return 0;
	}
	template <sizeType S>
	Byte<> compare(const T(&rarr)[S]) const noexcept {
		if (length > S - 1) {
			return 1;
		} else if (length < S - 1) {
			return -1;
		} else {
			for (sizeType i = 0;i < S - 1;++i) {
				if (_data[i] > rarr[i]) {
					return 1;
				} else if (_data[i] < rarr[i]) {
					return -1;
				}
			}
		}
		return 0;
	}
	BasicString& setWidthString(T _c, sizeType _count) noexcept {
		if (_count <= length)
			return *this;
		sizeType _t = length;
		for (sizeType i = 1;i <= _count - _t;++i) {
			appFront(_c);
		}
		return *this;
	}
	template <sizeType SIZE>
	void toCharArray(volatile T(&rarr)[SIZE], sizeType b = 0, sizeType e = SIZE) const noexcept {
		for (sizeType i = b;i < e and i < SIZE;++i)
			rarr[i] = _data[i - b];
	}
	template <sizeType MAX = 1024>
	BasicString& getLine(std::basic_istream<T> &cin, sizeType _s, char _end = '\n') noexcept {
		T _txt[MAX] {};
		cin.getline(_txt,_s,_end);
		for (sizeType i = 0;_txt[i] != '\0';++i)
			if (i == MAX or _txt[i + 1] == '\0')
				(*this) = (BasicString(_txt,0,i + 1));
		return *this;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& getLine(std::basic_istream<T> &cin) noexcept {
		return getLine(cin,capacity);
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	BasicString& getLine(std::basic_istream<T> &cin,char _e) noexcept {
		return getLine(cin,capacity,_e);
	}
	BasicString& swap(BasicString& r) noexcept {
		sizeType _t = r._size;
		r._size = _size;
		_size = _t;
		_t = r._capacity;
		r._capacity = _capacity;
		_capacity = _t;
		iterator _t2 = r._data;
		r._data = _data;
		_data = _t2;
		return *this;
	}
	#if _CPP_VERSION_ >= 17
		BasicString& operator=(const BasicString &as) & noexcept {
	#else
		BasicString& operator=(const BasicString &as) noexcept {
	#endif
		if (this == &as)
			return *this;
		if (_capacity < as.length)
			reNew(0,0,as.length);
		for (sizeType i = 0;i < as.length;++i)
			_data[i] = as[i];
		_size = as.length;
		return *this;
	}
	template <sizeType SIZE>
	#if _CPP_VERSION_ >= 17
		BasicString& operator=(const T(&rarr)[SIZE]) & noexcept {
	#else
		BasicString& operator=(const T(&rarr)[SIZE]) noexcept {
	#endif
		if (_capacity < SIZE - 1)
			reNew(0,0,SIZE - 1);
		for (sizeType i = 0;i < SIZE - 1;++i)
			_data[i] = rarr[i];
		_size = SIZE - 1;
		return *this;
	}
	#if _CPP_VERSION_ >= 17
		BasicString& operator=(BasicString &&move) & noexcept {
	#else
		BasicString& operator=(BasicString &&move) noexcept {
	#endif
		if (this == &move)
			return *this;
		_data   = move._data;
		move._data = nullptr;
		
		_size   = move._size;
		move._size = 0;
		
		_capacity   = move._capacity;
		move._capacity = 0;
		return *this;
	}
	#if _CPP_VERSION_ >= 17
		BasicString& operator=(const volatile T * const volatile p) & noexcept {
	#else
		BasicString& operator=(const volatile T * const volatile p) noexcept {
	#endif
		for (sizeType i = 0;p[i];++i) {
			if (p[i + 1] != 0 and i == capacity)
				reNew(0,0);
			else if (!(p[i + 1]))
				_size = i + 1;
			_data[i] = p[i];
		}
		return *this;
	}
	BasicString operator*(sizeType n) const noexcept {
		if (n == 1)
			return *this;
		else if (n == 0)
			return {};
		BasicString _r;
		_r.reLowestCapacity(length * n);
		for (sizeType i = 0;i < n;++i)
			for (sizeType j = 0;j < length;++j)
				_r.appEnd(_data[j]);
		return _r;
	}
	BasicString& operator*=(sizeType n) noexcept {
		if (n == 1) {
		} else if (n == 0) {
			clear();
		} else {
			reNew(0,0,length * n);
			const sizeType _ = n * length;
			for (sizeType i = 0;i < _;++i) {
				for (sizeType j = 0;j < length;++j) {
					_data[i * length + j] = _data[j];
				}
			}
			_size *= n;
		}
		return *this;
	}
	friend auto operator<<(std::basic_ostream<T>& cout, const BasicString& text) noexcept -> decltype(cout)& {
		for (T &i : text)
			if (i != 0)
				cout << i;
		return cout;
	}
	template <sizeType SIZE>
	constexpr friend bool operator==(const volatile T(&r)[SIZE], const BasicString &txt) noexcept {
		return txt.equals(r);
	}
	template <sizeType MAX = 1024>
	friend auto operator>>(std::basic_istream<T>& cin, BasicString<T>& text) noexcept -> decltype(cin)& {
		T _txt[MAX] {};
		cin >> _txt;
		for (sizeType i = 0;_txt[i] != '\0';++i)
			if (i == MAX or _txt[i + 1] == '\0')
				text = (BasicString(_txt,0,i + 1));
		return cin;
	}
	template <typename CT = T>
	static BasicString toString(bool _v, bool _t = true) noexcept {
		if (_v) {
			if (_t)
				return "True";
			else
				return "true";
		} else {
			if (_t)
				return "False";
			else
				return "false";
		}
	}
	template <>
	static BasicString toString<wchar_t>(bool _v, bool _t) noexcept {
		if (_v) {
			if (_t)
				return L"True";
			else
				return L"true";
		} else {
			if (_t)
				return L"False";
			else
				return L"false";
		}
	}
	template <>
	static BasicString toString<char16_t>(bool _v, bool _t) noexcept {
		if (_v) {
			if (_t)
				return u"True";
			else
				return u"true";
		} else {
			if (_t)
				return u"False";
			else
				return u"false";
		}
	}
	template <>
	static BasicString toString<char32_t>(bool _v, bool _t) noexcept {
		if (_v) {
			if (_t)
				return U"True";
			else
				return U"true";
		} else {
			if (_t)
				return U"False";
			else
				return U"false";
		}
	}
	static BasicString toString(T _c) noexcept {
		BasicString v;
		v.appEnd(_c);
		return v;
	}
	template <typename IT, typename std::enable_if<std::is_integral<IT>::value and !std::is_same<IT,bool>::value,int>::type = 0>
	static BasicString toString(IT _value) noexcept {
		BasicString _result;
		bool _sma = false;
		if (_value < 0) {
			_value = -_value;
			_sma = true;
		}
		do {
			_result.appFront(T(48 + _value % 10));
			_value /= 10;
		} while (_value != 0);
		if (_sma)
			_result.appFront((T)'-');
		return _result;
	}
	template <typename IT, sizeType SIZE>
	static BasicString toString(const volatile IT(&rarr)[SIZE]) noexcept {
		BasicString _res = toString((T)'[');
		for (sizeType i = 0;i < SIZE;++i) {
			_res.appEnd(toString(rarr[i]));
			if (i < SIZE - 1)
				_res.appEnd((T)',');
		}
		_res.appEnd((T)']');
		return _res;
	}
	static BasicString toString(const std::basic_string<T> &txt) noexcept {
		BasicString _r(txt.length());
		for (sizeType i = 0;i < txt.length();++i)
			_r[i] = txt[i];
		_r._size = txt.length();
		return _r;
	}
	template <class IT = int, typename std::enable_if<std::is_integral<IT>::value and !std::is_same<IT,bool>::value,int>::type = 0>
	static BasicString toString(long double v, IT b = 6) noexcept {
		bool _s = false;
		if (v < 0) {
			v = -v;
			_s = true;
		}
		BasicString _r;
		_r.appFront(toString((unsigned long)v));
		v -= (unsigned long)v;
		sizeType _t = _r.length;
		for (IT i = 1;i <= b;++i) {
			v *= 10;
			_r.appEnd(T(48 + (unsigned long)v));
			v -= (unsigned long)v;
		}
		if ((unsigned long)(v * 10) >= 5) {
			for (sizeType i = _r.length - 1;;--i) {
				decltype(_t) _t2 = _r[i] -47;
				if (_t2 >= 10) {
					if (i == 0) {
						_r[i] = (T)'0';
						_r.appFront((T)'1');
						++_t;
						break;
					} else {
						_r[i] = (_t2 % 10) + 48;
					}
				} else {
					_r[i] = 48 + _t2;
					break;
				}
			}
		}
		if (_r[_r.length - 1] == 48) {
			for (sizeType i = _r.length - 1;;--i) {
				if (_r[i] != 48 or i + 1 == _t) {
					_r.erase(i + 1,_r.length);
					break;
				}
			}
		}
		if (b != 0 and _r.length > _t)
			_r.insert((T)'.',_t);
		if (_s)
			_r.appFront((T)'-');
		return _r;
	}
	template <class IT = int, typename std::enable_if<std::is_integral<IT>::value and !std::is_same<IT,bool>::value,int>::type = 0>
	static BasicString toString(double v, IT b = 6) noexcept {
		bool _s = false;
		if (v < 0) {
			v = -v;
			_s = true;
		}
		BasicString _r;
		_r.appFront(toString((unsigned long)v));
		v -= (unsigned long)v;
		sizeType _t = _r.length;
		for (IT i = 1;i <= b;++i) {
			v *= 10;
			_r.appEnd(T(48 + (unsigned long)v));
			v -= (unsigned long)v;
		}
		if ((unsigned long)(v * 10) >= 5) {
			for (sizeType i = _r.length - 1;;--i) {
				decltype(_t) _t2 = _r[i] -47;
				if (_t2 >= 10) {
					if (i == 0) {
						_r[i] = (T)'0';
						_r.appFront((T)'1');
						++_t;
						break;
					} else {
						_r[i] = (_t2 % 10) + 48;
					}
				} else {
					_r[i] = 48 + _t2;
					break;
				}
			}
		}
		if (_r[_r.length - 1] == 48) {
			for (sizeType i = _r.length - 1;;--i) {
				if (_r[i] != 48 or i + 1 == _t) {
					_r.erase(i + 1,_r.length);
					break;
				}
			}
		}
		if (b != 0 and _r.length > _t)
			_r.insert((T)'.',_t);
		if (_s)
			_r.appFront((T)'-');
		return _r;
	}
	template <class IT = int, typename std::enable_if<std::is_integral<IT>::value and !std::is_same<IT,bool>::value,int>::type = 0>
	static BasicString toString(float v, IT b = 6) noexcept {
		bool _s = false;
		if (v < 0) {
			v = -v;
			_s = true;
		}
		BasicString _r;
		_r.appFront(toString((unsigned long)v));
		v -= (unsigned long)v;
		sizeType _t = _r.length;
		for (IT i = 1;i <= b;++i) {
			v *= 10;
			_r.appEnd(T(48 + (unsigned long)v));
			v -= (unsigned long)v;
		}
		if ((unsigned long)(v * 10) >= 5) {
			for (sizeType i = _r.length - 1;;--i) {
				decltype(_t) _t2 = _r[i] -47;
				if (_t2 >= 10) {
					if (i == 0) {
						_r[i] = (T)'0';
						_r.appFront((T)'1');
						++_t;
						break;
					} else {
						_r[i] = (_t2 % 10) + 48;
					}
				} else {
					_r[i] = 48 + _t2;
					break;
				}
			}
		}
		if (_r[_r.length - 1] == 48) {
			for (sizeType i = _r.length - 1;;--i) {
				if (_r[i] != 48 or i + 1  == _t) {
					_r.erase(i + 1,_r.length);
					break;
				}
			}
		}
		if (b != 0 and _r.length > _t)
			_r.insert((T)'.',_t);
		if (_s)
			_r.appFront((T)'-');
		return _r;
	}
	static BasicString<wchar_t> toWCharString(const BasicString<char> r) noexcept {
		BasicString<wchar_t> re(r.length,0);
		for (sizeType i = 0;i < r.length;++i)
			re[i] = r[i];
		return re;
	}
	static BasicString progress(
			sizeType          _max,
			decltype(_max)    _cur    = 0,
			bool              _per    = true,
			decltype(_cur)    _len    = 35,
			char              _bar    = '=',
			char              _space  = ' ',
			const BasicString &_tail  = BasicString(1,(T)'>'),
			const BasicString &_start = BasicString(1,(T)'['),
			const BasicString &_end   = BasicString(1,(T)']')
		) noexcept {
		BasicString _r = _start;
		if (_cur > _max)
			_cur = _max;
		else if (_len == 0) {
			_r.appEnd(_end);
			if (_per)
			    _r.appEnd((T)' ').appEnd(toString(_cur * 100 / _max)).appEnd((T)'%');
			return _r;
		}
		if (_cur == _max) {
		    _r.appEnd(BasicString(_len,(T)_bar)).appEnd(_end);
		    if (_per)
			    _r.appEnd((T)' ').appEnd(toString(_cur * 100 / _max)).appEnd((T)'%');
			return _r;
		} else if (_tail.length > _len) {
			_r.appEnd(BasicString(_len,(T)_space)).appEnd(_end);
			if (_per)
			    _r.appEnd((T)' ').appEnd(toString(_cur * 100 / _max)).appEnd((T)'%');
			   return _r;
		}
		if (_tail.length)
			_r.appEnd(BasicString((_cur * _len / _max) >= _tail.length ? (_cur * _len / _max) - _tail.length : 0,(T)_bar)).appEnd(_tail);
		else
			_r.appEnd(BasicString(_cur * _len / _max,(T)_bar));
		_r.appEnd(BasicString(_len - ((_cur * _len / _max) >= _tail.length ? (_cur * _len / _max) : _tail.length),(T)_space)).appEnd(_end);
		if (_per)
			    _r.appEnd((T)' ').appEnd(toString(_cur * 100 / _max)).appEnd((T)'%');
		return _r;
	}
	template <typename U>
	static BasicString toHex(U v, sizeType w = 8, bool _u = true) noexcept {
		static_assert(std::is_integral<U>::value
			and !std::is_same<U,bool>::value,"Illegal type");
		BasicString _r;
		if (v < 0)
			v = -v;
		do {
			T _t = v % 16;
			if (_t < 10) {
				_r.appFront(char(_t + 48));
			} else {
				if (_u) {
					_r.appFront(char(_t - 10 + 65));
				} else {
					_r.appFront(char(_t - 10 + 97));
				}
			}
			v /= 16;
		} while (v != 0);
		_r.setWidthString('0',w);
		return _r.appFront("0x");
	}
	template <typename U>
	static BasicString toBinary(U v, sizeType w = 8) noexcept {
		static_assert(std::is_integral<U>::value
			and !std::is_same<U,bool>::value,"Illegal type");
		bool _s = false;
		if (v < 0) {
			_s = true;
			v = -v;
			--v;
		}
		BasicString _r;
		do {
			if (_s) {
				_r.appFront(char(!(v % 2) + 48));
			} else {
				_r.appFront(char((v % 2) + 48));
			}
			v /= 2;
		} while (v != 0);
		if (_s) {
			_r.setWidthString('1',w);
			return _r.appFront('1');
		}
		return _r.setWidthString('0',w);
	}
	~BasicString() {
		if (_data != nullptr)
			delete [] _data;
	}
 private:
	iterator _data;
	sizeType _size,
		_capacity;
	template <sizeType SIZE>
	static T* initForText(const T(&text)[SIZE]) noexcept {
		T *data = new T[SIZE - 1];
		for (sizeType i = 0;i < SIZE - 1;++i)
			data[i] = text[i];
		return data;
	}
	template <sizeType SIZE>
	static T* initForArray(const volatile T(&arr)[SIZE], sizeType begin, sizeType end) noexcept {
		if (end <= begin or begin >= SIZE)
			return new T[SIZE];
		T *data = new T[end - begin];
		for (sizeType i = begin;i < end and i < SIZE;++i)
			data[i - begin] = arr[i];
		return data;
	}
	static T* initForCopy(const BasicString& copy) noexcept {
		T *data = new T[copy._size];
		for (sizeType i = 0;i < copy._size;++i)
			data[i] = copy._data[i];
		return data;
	}
	static T* initForString(const BasicString &txt, sizeType b, sizeType e) noexcept {
		if (e <= b or b >= txt.length)
			return new T[txt.length];
		T *data = new T[e - b];
		for (sizeType i = b;i < e and i < txt.length;++i)
			data[i - b] = txt[i];
		return data;
	}
	static T* initForInit(const std::initializer_list<T> &ini) noexcept {
		T *data = new T[ini.size()];
		for (sizeType i = 0;i < ini.size();++i)
			data[i] = *(ini.begin() + i);
		return data;
	}
	static T* initForStdString(const std::basic_string<T> &stxt) noexcept {
		T *data = new T[stxt.length()];
		for (sizeType i = 0;i < stxt.length();++i)
			data[i] = stxt[i];
		return data;
	}
	static T* initForChar(T _c, sizeType _cou) noexcept {
		T *data = new T[_cou];
		for (sizeType i = 0;i < _cou;++i)
			data[i] = _c;
		return data;
	}
	static T* initForString(const BasicString &_str, sizeType _cou) noexcept {
		sizeType _s = _str.length * _cou;
		T *data = new T[_s];
		for (sizeType i = 0;i < _s;i += _str.length)
			for (sizeType j = i;j < i + _str.length;++j)
				data[j] = _str[j - i];
		return data;
	}
	void reNew(sizeType in, sizeType in2, sizeType d) noexcept {
		sizeType newCap = (d == 0 ? 15 : (d * 2 - d / 2));
		T *tmp = new T[newCap];
		
		if (in == in2)
			memcpy(tmp,_data,length);
		else {
			memcpy(tmp,_data,in);
			memcpy(tmp + in2,_data + in,length - in);
		}
		if (_data != nullptr)
			delete [] _data;
		_data = tmp;
		_capacity = newCap;
	}
	#if _CPP_VERSION_ >= 14
	    constexpr
	#endif
	void reNew(sizeType in = 0, sizeType in2 = 0) noexcept {
		reNew(in,in2,_capacity);
	}
};
using String       = BasicString<char>;
using WString      = BasicString<wchar_t>;
using Char32String = BasicString<char32_t>;
using Char16String = BasicString<char16_t>;
using WCharString  = WString;

#define toStringMacro(X) String(#X)
#define toWStringMacro(X) WString(L ## #X)

#ifdef USER_NAMESPACE
}
#endif

#endif